{"name":"pipeR","tagline":"Multi-paradigm pipeline implementation for R","body":"\r\n\r\n# pipeR\r\n\r\n[![Build Status](https://travis-ci.org/renkun-ken/pipeR.png?branch=master)](https://travis-ci.org/renkun-ken/pipeR) [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/renkun-ken/pipeR?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\npipeR provides various styles of function chaining methods: \r\n\r\n* Pipe operator\r\n* Pipe object\r\n* pipeline function\r\n\r\nEach of them represents a distinct pipeline model but they share almost a common set of features. A value can be piped to the next expression as\r\n\r\n* The first unnamed argument of the function\r\n* Dot symbol in the expression\r\n* A named variable defined by a formula\r\n* Side-effect that branches the pipeline\r\n* Assignment that saves intermediate values of the pipeline\r\n\r\nThe set of syntax is designed to make the pipeline more readable and friendly to\r\na wide variety of operations.\r\n\r\n**[pipeR Tutorial](http://renkun.me/pipeR-tutorial) is a highly recommended complete guide to pipeR.**\r\n\r\n## Installation\r\n\r\nInstall the latest development version from GitHub:\r\n\r\n```r\r\ndevtools::install_github(\"renkun-ken/pipeR\")\r\n```\r\n\r\nInstall from [CRAN](http://cran.r-project.org/web/packages/pipeR/index.html):\r\n\r\n```r\r\ninstall.packages(\"pipeR\")\r\n```\r\n\r\n## Getting started\r\n\r\nThe following code is an example written in traditional approach:\r\n\r\nIt basically performs bootstrap on `mpg` values in built-in dataset `mtcars` and plots  its density function estimated by Gaussian kernel.\r\n\r\n```r\r\nplot(density(sample(mtcars$mpg, size = 10000, replace = TRUE), \r\n  kernel = \"gaussian\"), col = \"red\", main=\"density of mpg (bootstrap)\")\r\n```\r\n\r\nThe code is deeply nested and can be hard to read and maintain. In the following examples, the traditional code is rewritten by Pipe operator, `Pipe()` function and `pipeline()` function, respectively.\r\n\r\n* Operator-based pipeline\r\n\r\n```r\r\nmtcars$mpg %>>%\r\n  sample(size = 10000, replace = TRUE) %>>%\r\n  density(kernel = \"gaussian\") %>>%\r\n  plot(col = \"red\", main = \"density of mpg (bootstrap)\")\r\n```\r\n\r\n* Object-based pipeline (`Pipe()`)\r\n\r\n```r\r\nPipe(mtcars$mpg)$\r\n  sample(size = 10000, replace = TRUE)$\r\n  density(kernel = \"gaussian\")$\r\n  plot(col = \"red\", main = \"density of mpg (bootstrap)\")\r\n```\r\n\r\n* Argument-based pipeline\r\n\r\n```r\r\npipeline(mtcars$mpg,\r\n  sample(size = 10000, replace = TRUE),\r\n  density(kernel = \"gaussian\"),\r\n  plot(col = \"red\", main = \"density of mpg (bootstrap)\"))\r\n```\r\n\r\n* Expression-based pipeline\r\n\r\n```r\r\npipeline({\r\n  mtcars$mpg\r\n  sample(size = 10000, replace = TRUE)\r\n  density(kernel = \"gaussian\")\r\n  plot(col = \"red\", main = \"density of mpg (bootstrap)\")  \r\n})\r\n```\r\n\r\n## Usage\r\n\r\n### `%>>%`\r\n\r\nPipe operator `%>>%` basically pipes the left-hand side value forward to the right-hand side expression which is evaluated according to its syntax.\r\n\r\n#### Pipe to first-argument of function\r\n\r\nMany R functions are pipe-friendly: they take some data by the first argument and transform it in a certain way. This arrangement allows operations to be streamlined by pipes, that is, one data source can be put to the first argument of a function, get transformed, and put to the first argument of the next function. In this way, a chain of commands are connected, and it is called a pipeline.\r\n\r\nOn the right-hand side of `%>>%`, whenever a function name or call is supplied, the left-hand side value will always be put to the first unnamed argument to that function.\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  plot\r\n```\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  plot(col=\"red\")\r\n```\r\n\r\nSometimes the value on the left is needed at multiple places. One can use `.` to represent it anywhere in the function call.\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  plot(col=\"red\", main=length(.))\r\n```\r\n\r\nThere are situations where one calls a function in a namespace with `::`. In this case, the call must end up with `()`.\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  stats::median()\r\n  \r\nrnorm(100) %>>%\r\n  graphics::plot(col = \"red\")\r\n```\r\n\r\n#### Pipe to `.` in an expression\r\n\r\nNot all functions are pipe-friendly in every case: You may find some functions do not take your data produced by a pipeline as the first argument. In this case, you can enclose your expression by `{}` or `()` so that `%>>%` will use `.` to represent the value on the left.\r\n\r\n```r\r\nmtcars %>>%\r\n  { lm(mpg ~ cyl + wt, data = .) }\r\n```\r\n\r\n```r\r\nmtcars %>>%\r\n  ( lm(mpg ~ cyl + wt, data = .) )\r\n```\r\n\r\n#### Pipe by formula as lambda expression\r\n\r\nSometimes, it may look confusing to use `.` to represent the value being piped. For example,\r\n\r\n```r\r\nmtcars %>>%\r\n  (lm(mpg ~ ., data = .))\r\n```\r\n\r\nAlthough it works perfectly, it may look ambiguous if `.` has several meanings in one line of code. \r\n\r\n`%>>%` accepts lambda expression to direct its piping behavior. Lambda expression is characterized by a formula enclosed within `()`, for example, `(x ~ f(x))`. It contains a user-defined symbol to represent the value being piped and the expression to be evaluated.\r\n\r\n```r\r\nmtcars %>>%\r\n  (df ~ lm(mpg ~ ., data = df))\r\n```\r\n\r\n```r\r\nmtcars %>>%\r\n  subset(select = c(mpg, wt, cyl)) %>>%\r\n  (x ~ plot(mpg ~ ., data = x))\r\n```\r\n\r\n#### Pipe for side effect\r\n\r\nIn a pipeline, one may be interested not only in the final outcome but sometimes also in intermediate results. To print, plot or save the intermediate results, it must be a side-effect to avoid breaking the mainstream pipeline. For example, calling `plot()` to draw scatter plot returns `NULL`, and if one directly calls `plot()` in the middle of a pipeline, it would break the pipeline by changing the subsequent input to `NULL`.\r\n\r\nOne-sided formula that starts with `~` indicates that the right-hand side expression will only be evaluated for its side-effect, its value will be ignored, and the input value will be returned instead.\r\n\r\n```r\r\nmtcars %>>%\r\n  subset(mpg >= quantile(mpg, 0.05) & mpg <= quantile(mpg, 0.95)) %>>%\r\n  (~ cat(\"rows:\",nrow(.),\"\\n\")) %>>%   # cat() returns NULL\r\n  summary\r\n```\r\n\r\n```r\r\nmtcars %>>%\r\n  subset(mpg >= quantile(mpg, 0.05) & mpg <= quantile(mpg, 0.95)) %>>%\r\n  (~ plot(mpg ~ wt, data = .)) %>>%    # plot() returns NULL\r\n  (lm(mpg ~ wt, data = .)) %>>%\r\n  summary()\r\n```\r\n\r\nWith `~`, side-effect operations can be easily distinguished from mainstream pipeline.\r\n\r\nAn easier way to print the intermediate value it to use `(? expr)` syntax like asking question.\r\n\r\n```r\r\nmtcars %>>% \r\n  (? ncol(.)) %>>%\r\n  summary\r\n```\r\n\r\n#### Pipe with assignment\r\n\r\nIn addition to printing and plotting, one may need to save an intermediate value to the environment by assigning the value to a variable (symbol).\r\n\r\nIf one needs to assign the value to a symbol, just insert a step like `(~ symbol)`, then the input value of that step will be assigned to `symbol` in the current environment.\r\n\r\n```r\r\nmtcars %>>%\r\n  (lm(formula = mpg ~ wt + cyl, data = .)) %>>%\r\n  (~ lm_mtcars) %>>%\r\n  summary\r\n```\r\n\r\nIf the input value is not directly to be saved but after some transformation, then one can use `=`, `<-`, or more natural `->` to specify a lambda expression to tell what to be saved (thanks @yanlinlin82 for suggestion).\r\n\r\n```r\r\nmtcars %>>%\r\n  (~ summ = summary(.)) %>>%  # side-effect assignment\r\n  (lm(formula = mpg ~ wt + cyl, data = .)) %>>%\r\n  (~ lm_mtcars) %>>%\r\n  summary\r\n```\r\n\r\n```r\r\nmtcars %>>%\r\n  (~ summary(.) -> summ) %>>%\r\n  \r\nmtcars %>>%\r\n  (~ summ <- summary(.)) %>>%\r\n```\r\n\r\nAn easier way to saving intermediate value that is to be further piped is to use `(symbol = expression)` syntax:\r\n\r\n```r\r\nmtcars %>>%\r\n  (~ summ = summary(.)) %>>%  # side-effect assignment\r\n  (lm_mtcars = lm(formula = mpg ~ wt + cyl, data = .)) %>>%  # continue piping\r\n  summary\r\n```\r\n\r\nor `(expression -> symbol)` syntax:\r\n\r\n```r\r\nmtcars %>>%\r\n  (~ summary(.) -> summ) %>>%  # side-effect assignment\r\n  (lm(formula = mpg ~ wt + cyl, data = .) -> lm_mtcars) %>>%  # continue piping\r\n  summary\r\n```\r\n\r\n#### Extract element from an object\r\n\r\n`x %>>% (y)` means extracting the element named `y` from object `x` where `y` must be a valid symbol name and `x` can be a vector, list, environment or anything else for which `[[]]` is defined, or S4 object.\r\n\r\n```r\r\nmtcars %>>%\r\n  (lm(mpg ~ wt + cyl, data = .)) %>>%\r\n  (~ lm_mtcars) %>>%\r\n  summary %>>%\r\n  (r.squared)\r\n```\r\n\r\n#### Compatibility\r\n\r\n* Working with [dplyr](https://github.com/hadley/dplyr/):\r\n\r\n```r\r\nlibrary(dplyr)\r\nmtcars %>>%\r\n  filter(mpg <= mean(mpg)) %>>%  \r\n  select(mpg, wt, cyl) %>>%\r\n  (~ plot(.)) %>>%\r\n  (model = lm(mpg ~ wt + cyl, data = .)) %>>%\r\n  (summ = summary(.)) %>>%\r\n  (coefficients)\r\n```\r\n\r\n* Working with [ggvis](http://ggvis.rstudio.com/):\r\n\r\n```r\r\nlibrary(ggvis)\r\nmtcars %>>%\r\n  ggvis(~mpg, ~wt) %>>%\r\n  layer_points()\r\n```\r\n\r\n* Working with [rlist](http://renkun.me/rlist/):\r\n\r\n```r\r\nlibrary(rlist)\r\n1:100 %>>%\r\n  list.group(. %% 3) %>>%\r\n  list.mapv(g ~ mean(g))\r\n```\r\n\r\n### `Pipe()`\r\n\r\n`Pipe()` creates a Pipe object that supports light-weight chaining without any external operator. Typically, start with `Pipe()` and end with `$value` or `[]` to extract the final value of the Pipe. \r\n\r\nPipe object provides an internal function `.(...)` that work exactly in the same way with `x %>>% (...)`, and it has more features than `%>>%`.\r\n\r\n> NOTE: `.()` does not support assignment with `=` but supports `~`, `<-` and `->`.\r\n\r\n#### Piping\r\n\r\n```r\r\nPipe(rnorm(1000))$\r\n  density(kernel = \"cosine\")$\r\n  plot(col = \"blue\")\r\n```\r\n\r\n```r\r\nPipe(mtcars)$\r\n  .(mpg)$\r\n  summary()\r\n```\r\n\r\n```r\r\nPipe(mtcars)$\r\n  .(~ summary(.) -> summ)$\r\n  lm(formula = mpg ~ wt + cyl)$\r\n  summary()$\r\n  .(coefficients)\r\n```\r\n\r\n#### Subsetting and extracting\r\n\r\n```r\r\npmtcars <- Pipe(mtcars)\r\npmtcars[c(\"mpg\",\"wt\")]$\r\n  lm(formula = mpg ~ wt)$\r\n  summary()\r\npmtcars[[\"mpg\"]]$mean()\r\n```\r\n\r\n#### Assigning values\r\n\r\n```r\r\nplist <- Pipe(list(a=1,b=2))\r\nplist$a <- 0\r\nplist$b <- NULL\r\n```\r\n\r\n#### Side effect\r\n\r\n```r\r\nPipe(mtcars)$\r\n  .(? ncol(.))$\r\n  .(~ plot(mpg ~ ., data = .))$    # side effect: plot\r\n  lm(formula = mpg ~ .)$\r\n  .(~ lm_mtcars)$                  # side effect: assign\r\n  summary()$\r\n```\r\n\r\n#### Compatibility\r\n\r\n* Working with dplyr:\r\n\r\n```r\r\nPipe(mtcars)$\r\n  filter(mpg >= mean(mpg))$\r\n  select(mpg, wt, cyl)$\r\n  lm(formula = mpg ~ wt + cyl)$\r\n  summary()$\r\n  .(coefficients)$\r\n  value\r\n```\r\n\r\n* Working with ggvis:\r\n\r\n```r\r\nPipe(mtcars)$\r\n  ggvis(~ mpg, ~ wt)$\r\n  layer_points()\r\n```\r\n\r\n* Working with rlist:\r\n\r\n```r\r\nPipe(1:100)$\r\n  list.group(. %% 3)$\r\n  list.mapv(g ~ mean(g))$\r\n  value\r\n```\r\n\r\n### `pipeline()`\r\n\r\n`pipeline()` provides argument-based and expression-based pipeline evaluation mechanisms. Its behavior depends on how its arguments are supplied. If only the first argument is supplied, it expects an expression enclosed in `{}` in which each line represents a pipeline step. If, instead, multiple arguments are supplied, it regards each argument as a pipeline step. For all pipeline steps, the expressions will be transformed to be connected by `%>>%` so that they behave exactly the same.\r\n\r\nOne notable difference is that in `pipeline()`'s argument or expression, the special symbols to perform specially defined pipeline tasks (e.g. side-effect) does not need to be enclosed within `()` because no operator priority issues arise as they do in using `%>>%`.\r\n\r\n```r\r\npipeline({\r\n  mtcars\r\n  lm(formula = mpg ~ cyl + wt)\r\n  ~ lmodel\r\n  summary\r\n  ? .$r.squared\r\n  coef\r\n})\r\n```\r\n\r\nThanks [@hoxo_m](https://twitter.com/hoxo_m) for the idea presented in this [post](http://qiita.com/hoxo_m/items/3fd3d2520fa014a248cb).\r\n\r\n## License\r\n\r\nThis package is under [MIT License](http://opensource.org/licenses/MIT).\r\n","google":"UA-47159422-1","note":"Don't delete this file! It's used internally to help with page regeneration."}